<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Moto Delivery - Camera Inteligente</title>
    <style>
        body { 
            margin: 0; padding: 0; overflow: hidden; 
            font-family: 'Segoe UI', sans-serif;
            background-color: #000; 
            background-image: url('fundo2.jpg'); 
            background-repeat: repeat-x; 
            background-size: auto 100vh; 
            background-position: 0px 0px; 
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none;
        }

        /* TELA DE ROTA√á√ÉO */
        #rotateOverlay {
            display: none; 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #2c3e50; z-index: 9999;
            flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center;
        }
        .rotate-icon { font-size: 80px; margin-bottom: 20px; animation: rotatePhone 2s infinite ease-in-out; }
        @keyframes rotatePhone { 0% { transform: rotate(0deg); } 50% { transform: rotate(-90deg); } 100% { transform: rotate(0deg); } }

        @media screen and (orientation: portrait) {
            #rotateOverlay { display: flex; }
            #gameContainer { display: none; }
        }

        /* UI DO JOGO */
        #resetBtn {
            position: absolute; top: 20px; left: 20px;
            background: #e74c3c; color: white; border: 2px solid #fff;
            padding: 8px 15px; border-radius: 20px; font-weight: bold;
            cursor: pointer; z-index: 20; box-shadow: 0 4px 5px rgba(0,0,0,0.3);
            font-size: 14px;
        }

        .touch-controls {
            position: absolute; bottom: 20px;
            z-index: 100; display: flex; gap: 20px;
        }
        
        .controls-left { left: 30px; }
        .controls-right { right: 30px; align-items: flex-end; }

        .btn {
            width: 70px; height: 70px; 
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white; font-size: 28px; font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(4px);
            transition: transform 0.1s, background 0.1s;
            -webkit-tap-highlight-color: transparent;
        }

        .btn:active, .btn.pressed {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.90);
        }

        .btn-gas { width: 90px; height: 90px; background: rgba(46, 204, 113, 0.2); border-color: #2ecc71; }
        .btn-brake { width: 65px; height: 65px; background: rgba(231, 76, 60, 0.2); border-color: #c0392b; margin-right: 15px; }
        .btn-arrow { font-size: 35px; }

        .gas-group { display: flex; align-items: flex-end; }

        .score-board { 
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); padding: 5px 20px; border-radius: 30px;
            border: 2px solid #fff; color: #fff; font-size: 20px; font-weight: bold;
            z-index: 10; white-space: nowrap;
        }
        #scoreVal { color: #f1c40f; }

        #centerMessageContainer {
            position: absolute; top: 30%; left: 50%;
            transform: translate(-50%, -50%); text-align: center; z-index: 90;
            pointer-events: none; display: none;
            text-shadow: 3px 3px 0 #000;
            font-family: 'Impact', sans-serif; text-transform: uppercase; white-space: nowrap;
        }
        .stage1 { color: #f1c40f; font-size: 40px; } 
        .stage2 { color: #e67e22; font-size: 45px; } 
        .stage3 { color: #2ecc71; font-size: 55px; } 
        .stage4 { color: #3498db; font-size: 70px; animation: pulseBig 0.5s infinite alternate; }
        @keyframes pulseBig { from { transform: scale(1); } to { transform: scale(1.1); } }

        #balanceContainer {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 150px; height: 10px; background: rgba(0,0,0,0.5);
            border-radius: 10px; border: 2px solid #fff; display: none; overflow: hidden; z-index: 10;
        }
        #balanceFill { height: 100%; width: 0%; background: linear-gradient(90deg, #f1c40f, #e74c3c); transition: width 0.1s linear; }

        #dashboard { position: absolute; top: 10px; right: 10px; display: flex; gap: 10px; z-index: 10; pointer-events: none; transform: scale(0.6); transform-origin: top right; }
        .gauge { width: 180px; height: 180px; background: #f4e6c0; border-radius: 50%; border: 8px solid #5d4037; box-shadow: inset 0 0 20px rgba(0,0,0,0.5), 0 0 0 4px #8d6e63; position: relative; display: flex; justify-content: center; align-items: center; }
        .gauge::after, .gauge::before { content: ''; position: absolute; width: 8px; height: 8px; background: #aaa; border-radius: 50%; }
        .gauge::after { top: 5px; left: 50%; transform: translateX(-50%); box-shadow: 0 154px 0 #aaa; }
        .gauge::before { left: 5px; top: 50%; transform: translateY(-50%); box-shadow: 154px 0 0 #aaa; }
        .gauge-face { width: 100%; height: 100%; position: relative; font-family: 'Courier New', monospace; font-weight: bold; color: #222; }
        .label-kmh { position: absolute; top: 65%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; color: #333; }
        .label-title { position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%); font-size: 14px; color: #5d4037; font-weight: bold; text-transform: uppercase; }
        .needle { position: absolute; top: 50%; left: 50%; width: 6px; height: 70px; background: #c0392b; border-radius: 5px; transform-origin: bottom center; transform: translate(-50%, -100%) rotate(-135deg); box-shadow: 2px 2px 5px rgba(0,0,0,0.3); transition: transform 0.1s linear; z-index: 2; }
        .needle-center { position: absolute; top: 50%; left: 50%; width: 16px; height: 16px; background: #333; transform: translate(-50%, -50%); border-radius: 50%; z-index: 3; }
        #woodSign { position: absolute; top: -50px; left: 50%; transform: translateX(-50%); background: #8b4513; color: #fff; padding: 5px 15px; border: 2px solid #5d4037; border-radius: 4px; font-family: 'Comic Sans MS', cursive; font-size: 14px; white-space: nowrap; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        
        #startOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); color: #fff; z-index: 300; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #startOverlay h1 { font-size: 24px; margin-bottom: 20px; text-transform: uppercase; }
        #startBtn { padding: 15px 40px; font-size: 20px; background: #27ae60; color: white; border: none; border-radius: 10px; font-weight: bold; cursor: pointer; box-shadow: 0 5px 0 #219150; }
        #startBtn:active { transform: translateY(5px); box-shadow: none; }
        #audioFileControl { display: none; margin-top: 20px; background: #f1c40f; padding: 10px; border-radius: 5px; color: black; font-weight: bold; text-align: center; }

        #messageScreen { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #e74c3c; color: white; padding: 30px; border-radius: 20px; text-align: center; border: 5px solid white; z-index: 200; box-shadow: 0 10px 30px rgba(0,0,0,0.3); width: 80%; max-width: 400px; }
        #messageScreen.win { background: #2ecc71; }
        #messageScreen h1 { margin: 0 0 10px 0; font-size: 28px; }
        #messageScreen button { background: white; color: #333; margin-top: 20px; padding: 10px 20px; border:none; font-weight:bold; cursor:pointer; font-size: 16px; border-radius: 5px;}
    </style>
</head>
<body>

<div id="rotateOverlay">
    <div class="rotate-icon">üì±</div>
    <h2>GIRE O CELULAR</h2>
    <p>Este jogo funciona melhor deitado.</p>
</div>

<div id="startOverlay">
    <h1>Moto Delivery</h1>
    <button id="startBtn">JOGAR AGORA ‚ñ∂</button>
    <div id="audioFileControl">
        ‚ö†Ô∏è Arquivos de √°udio bloqueados.<br>Selecione idle.mp3 e rev.mp3:<br>
        <input type="file" id="soundFilesInput" multiple accept="audio/*" style="margin-top:5px;">
    </div>
</div>

<div id="gameContainer">
    <div id="balanceContainer"><div id="balanceFill"></div></div>
    <button id="resetBtn" onclick="resetGame()">‚Ü∫</button>
    <div class="score-board">PTS: <span id="scoreVal">0</span></div>
    <div id="centerMessageContainer"><div id="centerMessageText"></div></div>

    <div id="dashboard">
        <div class="gauge">
            <div id="woodSign">Arroio do Mal</div>
            <div class="gauge-face">
                <div class="label-title">VELOCIDADE</div>
                <div class="label-kmh"><span id="speedVal">0</span> <small>km/h</small></div>
            </div>
            <div class="needle" id="needle"></div>
            <div class="needle-center"></div>
        </div>
    </div>

    <div class="touch-controls controls-left">
        <div class="btn btn-arrow" id="btnLeft">‚Ü∫</div>
        <div class="btn btn-arrow" id="btnRight" style="margin-left: 10px;">‚Üª</div>
    </div>
    <div class="touch-controls controls-right">
        <div class="gas-group">
            <div class="btn btn-brake" id="btnDown">üõë</div>
            <div class="btn btn-gas" id="btnUp">üöÄ</div>
        </div>
    </div>

    <div id="messageScreen">
        <h1 id="msgTitle">CRASH! üí•</h1>
        <p id="msgText">Voc√™ virou a moto.</p>
        <button onclick="resetGame()">TENTAR NOVAMENTE</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

<script>
    const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
          Bodies = Matter.Bodies, Body = Matter.Body, Composite = Matter.Composite,
          Constraint = Matter.Constraint, Events = Matter.Events, Vector = Matter.Vector, Query = Matter.Query;

    const engine = Engine.create();
    const world = engine.world;
    
    engine.positionIterations = 10; 
    engine.velocityIterations = 10;
    world.gravity.y = 1.2; 

    const render = Render.create({
        element: document.body, engine: engine,
        options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: 'transparent', hasBounds: true }
    });

    let chassis, riderBody, bikeComposite, currentStats, isGameOver = false;
    let groundBodies = []; 
    let score = 0; 
    let wheelieStartTime = null; 

    const FINISH_LINE_X = 45000;
    const SCALE_FACTOR = 1.25; 

    // --- AUDIO ---
    let audioCtx, idleSource, revSource, idleGain, revGain;
    let audioInitialized = false;
    let idleBuffer, revBuffer;

    function initAudioContext() {
        if (!audioCtx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
        }
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    async function startGame() {
        if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen().catch(e => console.log(e));
        }
        
        initAudioContext();
        try {
            const iBuff = await fetch('idle.mp3').then(res => res.arrayBuffer());
            const rBuff = await fetch('rev.mp3').then(res => res.arrayBuffer());
            idleBuffer = await audioCtx.decodeAudioData(iBuff);
            revBuffer = await audioCtx.decodeAudioData(rBuff);
            setupAudioNodes();
            startEngineSounds();
            audioInitialized = true;
            document.getElementById('startOverlay').style.display = 'none';
            resetGame(); 
        } catch (e) {
            document.getElementById('audioFileControl').style.display = 'block';
        }
    }

    document.getElementById('startBtn').addEventListener('click', startGame);

    document.getElementById('soundFilesInput').addEventListener('change', async function(e) {
        initAudioContext();
        const files = e.target.files;
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            if (file.name.toLowerCase().includes('idle')) idleBuffer = audioBuffer;
            if (file.name.toLowerCase().includes('rev')) revBuffer = audioBuffer;
        }
        if (idleBuffer && revBuffer) {
            setupAudioNodes();
            startEngineSounds();
            audioInitialized = true;
            document.getElementById('startOverlay').style.display = 'none';
            resetGame();
        }
    });

    function setupAudioNodes() {
        const distortion = audioCtx.createWaveShaper();
        function makeDistortionCurve(amount) {
            let k = amount, n_samples = 44100, curve = new Float32Array(n_samples), deg = Math.PI / 180, i = 0, x;
            for ( ; i < n_samples; ++i ) {
                x = i * 2 / n_samples - 1;
                curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) );
            }
            return curve;
        }
        distortion.curve = makeDistortionCurve(20); 
        distortion.oversample = '4x';

        idleGain = audioCtx.createGain();
        revGain = audioCtx.createGain();
        
        idleGain.connect(audioCtx.destination);
        revGain.connect(distortion);
        distortion.connect(audioCtx.destination);
    }

    function startEngineSounds() {
        if(idleSource) try{idleSource.stop()}catch(e){}
        if(revSource) try{revSource.stop()}catch(e){}

        idleSource = audioCtx.createBufferSource();
        idleSource.buffer = idleBuffer; idleSource.loop = true;
        idleSource.connect(idleGain);

        revSource = audioCtx.createBufferSource();
        revSource.buffer = revBuffer; revSource.loop = true;
        revSource.connect(revGain);

        idleSource.start(0); revSource.start(0);
    }

    // --- GAME LOGIC ---
    const BIKE_SPECS = {
        name: "Landera do Douglas",
        bodyTexture: 'lander_corpo.png', rearWheelTexture: 'lander_roda_tras.png', frontWheelTexture: 'lander_roda_frente.png',
        riderTexture: 'piloto.png', riderScale: 0.15, riderOffset: {x: -22, y: -29},
        bodyScale: 0.169, rearWheelScale: 0.05, frontWheelScale: 0.054,
        axleOffset: 60, bodyHeight: 40,
        color: '#111', wheelSize: 24, clearance: 30,
        density: 0.5, torque: 0.45, climbForce: 0.3, maxSpeedKmh: 180, rotationSpeed: 0.004, maxRotation: 0.12
    };

    function createBike(x, y) {
        const stats = BIKE_SPECS;
        currentStats = stats;
        const group = Body.nextGroup(true); 
        const S = SCALE_FACTOR; 

        const chassisW = 110 * S;
        const chassisH = 30 * S;
        const wheelSizeScaled = (stats.wheelSize || 24) * S;
        const axleOffsetScaled = stats.axleOffset * S;
        const bodyHeightScaled = stats.bodyHeight * S;

        let renderBody = { fillStyle: stats.color, strokeStyle: 'black', lineWidth: 2 };
        let renderRear = { fillStyle: 'transparent', strokeStyle: '#222', lineWidth: 8 * S };
        let renderFront = { fillStyle: 'transparent', strokeStyle: '#222', lineWidth: 8 * S };
        let renderRider = { fillStyle: '#f1c27d', strokeStyle: '#333', lineWidth: 2 };

        if (stats.bodyTexture) renderBody = { sprite: { texture: stats.bodyTexture, xScale: stats.bodyScale * S, yScale: stats.bodyScale * S } };
        if (stats.rearWheelTexture) renderRear = { sprite: { texture: stats.rearWheelTexture, xScale: stats.rearWheelScale * S, yScale: stats.rearWheelScale * S } };
        if (stats.frontWheelTexture) renderFront = { sprite: { texture: stats.frontWheelTexture, xScale: stats.frontWheelScale * S, yScale: stats.frontWheelScale * S } };
        if (stats.riderTexture) renderRider = { sprite: { texture: stats.riderTexture, xScale: stats.riderScale * S, yScale: stats.riderScale * S } };
        
        chassis = Bodies.rectangle(x, y - 30 * S, chassisW, chassisH, { collisionFilter: { group: group }, density: stats.density, friction: 0.5, frictionAir: 0.03, render: renderBody, label: 'chassis' });

        const currentOffsetX = stats.riderOffset.x;
        const currentOffsetY = stats.riderOffset.y;
        const riderSize = 25 * S; 
        const riderStartX = x + (currentOffsetX * S);
        const riderStartY = (y - 30 * S) + (currentOffsetY * S);

        riderBody = Bodies.circle(riderStartX, riderStartY, riderSize, { collisionFilter: { group: group }, density: 0.05, friction: 0.5, render: renderRider, label: 'rider' });

        const riderJoint = Constraint.create({ bodyA: chassis, bodyB: riderBody, pointA: { x: currentOffsetX * S, y: currentOffsetY * S }, pointB: { x: 0, y: 0 }, stiffness: 1, damping: 0.1, length: 0, render: { visible: false } });

        const wheelOptsRear = { collisionFilter: { group: group }, friction: 0.8, density: 0.05, restitution: 0, render: renderRear, label: 'wheelRear' }; 
        const wheelOptsFront = { collisionFilter: { group: group }, friction: 0.8, density: 0.05, restitution: 0, render: renderFront, label: 'wheelFront' }; 
        
        const wheelY = y + 15 * S; 
        const wheelRear = Bodies.circle(x - axleOffsetScaled, wheelY, wheelSizeScaled, wheelOptsRear);
        const wheelFront = Bodies.circle(x + axleOffsetScaled, wheelY, wheelSizeScaled, wheelOptsFront);

        const suspensionOptions = { stiffness: 0.3, damping: 0.3, length: 0, render: { visible: false } };

        const axelRear = Constraint.create({ bodyA: chassis, bodyB: wheelRear, pointA: { x: -axleOffsetScaled, y: bodyHeightScaled }, pointB: { x: 0, y: 0 }, ...suspensionOptions });
        const axelFront = Constraint.create({ bodyA: chassis, bodyB: wheelFront, pointA: { x: axleOffsetScaled, y: bodyHeightScaled }, pointB: { x: 0, y: 0 }, ...suspensionOptions });

        bikeComposite = Composite.create({ bodies: [chassis, wheelRear, wheelFront, riderBody], constraints: [axelRear, axelFront, riderJoint] });
        Composite.add(world, bikeComposite);
        chassis.wheelRear = wheelRear;
        chassis.wheelFront = wheelFront;
    }

    function createLevel() {
        groundBodies = []; 
        const T = 40; const C = '#000000'; 
        const groundOpts = { isStatic: true, friction: 1, restitution: 0, render: { fillStyle: C }, label: 'ground' };
        const pts = [ 
            {x:0,y:500},{x:1000,y:500}, {x:1400,y:600},{x:1800,y:450},{x:2200,y:600}, {x:3000,y:500},{x:4000,y:800}, {x:6000,y:1100},{x:7500,y:1100}, {x:10000,y:200}, 
            {x:11000,y:200},{x:13000,y:600}, {x:15000,y:600},{x:17000,y:400},{x:19000,y:600}, {x:21000,y:500},{x:22000,y:500}, {x:24000,y:700},{x:26000,y:300}, 
            {x:28000,y:300},{x:30000,y:800}, {x:32000,y:800},{x:33000,y:600},{x:34000,y:800}, {x:36000,y:500},{x:38000,y:200}, {x:40000,y:500},{x:42000,y:500},{x:45000,y:500} 
        ];
        for(let i=0; i<pts.length-1; i++){
            let corner = Bodies.circle(pts[i].x, pts[i].y, T/2, groundOpts); groundBodies.push(corner);
            let v = Vector.sub(pts[i+1], pts[i]), len = Vector.magnitude(v), ang = Vector.angle(v, {x:1,y:0}), mid = Vector.add(pts[i], Vector.mult(v,0.5));
            let rect = Bodies.rectangle(mid.x, mid.y, len+T, T, { ...groundOpts, angle: ang }); groundBodies.push(rect);
        }
        groundBodies.push(Bodies.circle(pts[pts.length-1].x, pts[pts.length-1].y, T/2, groundOpts));
        Composite.add(world, [...groundBodies, 
            Bodies.rectangle(FINISH_LINE_X, 450, 15, 300, { isStatic: true, isSensor: true, render: { fillStyle: '#fff' } }),
            Bodies.rectangle(FINISH_LINE_X + 50, 320, 100, 80, { isStatic: true, isSensor: true, render: { fillStyle: '#e74c3c' } }),
            Bodies.rectangle(FINISH_LINE_X, 600, 200, 10, { isStatic: true, render: { fillStyle: '#fff' } })
        ]);
    }

    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    window.addEventListener('keydown', e => { if(e.key.toLowerCase() === 'r') resetGame(); });

    function addTouch(elemId, keyCode) {
        const el = document.getElementById(elemId);
        const handlePress = (e) => { e.preventDefault(); keys[keyCode] = true; el.classList.add('pressed'); };
        const handleRelease = (e) => { e.preventDefault(); keys[keyCode] = false; el.classList.remove('pressed'); };
        el.addEventListener('touchstart', handlePress); el.addEventListener('touchend', handleRelease);
        el.addEventListener('mousedown', handlePress); el.addEventListener('mouseup', handleRelease); el.addEventListener('mouseleave', handleRelease);
    }
    addTouch('btnUp', 'ArrowUp'); addTouch('btnDown', 'ArrowDown'); addTouch('btnLeft', 'ArrowLeft'); addTouch('btnRight', 'ArrowRight');

    function showCenterMessage(text, className) {
        const container = document.getElementById('centerMessageContainer');
        const msgText = document.getElementById('centerMessageText');
        msgText.innerText = text; msgText.className = className; container.style.display = 'block';
    }

    function endGame(won) {
        isGameOver = true;
        if(audioInitialized && idleGain) { idleGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.2); revGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.2); }
        document.getElementById('centerMessageContainer').style.display = 'none'; 
        const screen = document.getElementById('messageScreen');
        const title = document.getElementById('msgTitle');
        const txt = document.getElementById('msgText');
        screen.style.display = 'block';
        if(won) { screen.className = 'win'; title.innerText = "ENTREGUE! üì¶"; txt.innerText = `Pontua√ß√£o Final: ${score}`; }
        else { screen.className = ''; title.innerText = "CRASH! üí•"; txt.innerText = "Voc√™ virou a moto."; }
    }

    function resetGame() {
        document.getElementById('messageScreen').style.display = 'none';
        document.getElementById('balanceContainer').style.display = 'none';
        document.getElementById('centerMessageContainer').style.display = 'none';
        isGameOver = false; score = 0; wheelieStartTime = null; 
        document.getElementById('scoreVal').innerText = score;
        if(bikeComposite) Composite.remove(world, bikeComposite);
        createBike(100, 400);
        if(audioInitialized && idleGain) { 
            idleGain.gain.setTargetAtTime(1.0, audioCtx.currentTime, 0.1);
            revGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            if(audioCtx.state === 'suspended') audioCtx.resume();
        }
    }

    Events.on(render, 'afterRender', () => {
        if (!chassis || !chassis.wheelRear) return;
        if (!currentStats.rearWheelTexture) {
            const ctx = render.context; ctx.beginPath(); ctx.lineWidth = 4; ctx.strokeStyle = '#333';
            const wr = chassis.wheelRear;
            ctx.moveTo(wr.position.x, wr.position.y);
            ctx.lineTo(wr.position.x + Math.cos(wr.angle)*wr.circleRadius, wr.position.y + Math.sin(wr.angle)*wr.circleRadius);
            ctx.stroke();
        }
    });

    Events.on(engine, 'collisionStart', (event) => {
        if(isGameOver) return;
        const pairs = event.pairs;
        for (let i = 0; i < pairs.length; i++) {
            const bodyA = pairs[i].bodyA; const bodyB = pairs[i].bodyB;
            if ((bodyA.label === 'chassis' && bodyB.label === 'ground') || (bodyB.label === 'chassis' && bodyA.label === 'ground') ||
                (bodyA.label === 'rider' && bodyB.label === 'ground') || (bodyB.label === 'rider' && bodyA.label === 'ground')) { 
                endGame(false); 
            }
        }
    });

    Events.on(engine, 'beforeUpdate', () => {
        if (!chassis || isGameOver) return;
        if (riderBody && chassis) { Body.setAngle(riderBody, chassis.angle); Body.setAngularVelocity(riderBody, chassis.angularVelocity); }
        if (chassis.position.x >= FINISH_LINE_X) endGame(true);

        const wr = chassis.wheelRear; const wf = chassis.wheelFront;
        const speed = Vector.magnitude(chassis.velocity); const kmh = Math.round(speed * 15);

        if(audioInitialized && idleGain && revGain) {
            const isThrottle = keys['ArrowUp'];
            let rpm = (Math.min(kmh, 140) / 140) + (isThrottle ? 0.2 : 0);
            rpm = Math.min(Math.max(rpm, 0), 1);
            idleGain.gain.setTargetAtTime(Math.max(0, 1.0 - (rpm * 2)), audioCtx.currentTime, 0.1);
            revGain.gain.setTargetAtTime(Math.min(1, rpm * 1.5), audioCtx.currentTime, 0.1);
            idleSource.playbackRate.value = 0.9 + (rpm * 0.1);
            revSource.playbackRate.value = 0.7 + (rpm * 0.6);
        }

        const rearCollisions = Query.collides(wr, groundBodies);
        const frontCollisions = Query.collides(wf, groundBodies);
        const rearOnGround = rearCollisions.length > 0;
        const frontOnGround = frontCollisions.length > 0;
        const isDoingWheelie = rearOnGround && !frontOnGround && kmh > 10;

        if (isDoingWheelie) {
            if (wheelieStartTime === null) { wheelieStartTime = Date.now(); }
            const currentDuration = (Date.now() - wheelieStartTime) / 1000;
            let pointsMultiplier = 1;
            if (currentDuration > 8) { showCenterMessage("Mestre do Grau!! üëë", "stage4"); pointsMultiplier = 20; } 
            else if (currentDuration > 5) { showCenterMessage("Bom Grau! üëç", "stage3"); pointsMultiplier = 10; } 
            else if (currentDuration > 4) { showCenterMessage("Grau Murcho üòê", "stage2"); pointsMultiplier = 5; } 
            else if (currentDuration > 1) { showCenterMessage("Chama no Grau!! üî•", "stage1"); pointsMultiplier = 2; }
            if (currentDuration > 1) { score += pointsMultiplier; document.getElementById('scoreVal').innerText = score; }
        } else {
            wheelieStartTime = null;
            document.getElementById('centerMessageContainer').style.display = 'none';
        }

        const MAX_WHEEL_SPIN = 0.6;
        if (wr.angularVelocity > MAX_WHEEL_SPIN) Body.setAngularVelocity(wr, MAX_WHEEL_SPIN);
        if (wr.angularVelocity < -MAX_WHEEL_SPIN) Body.setAngularVelocity(wr, -MAX_WHEEL_SPIN);

        // --- C√ÇMERA INTELIGENTE (ADAPTATIVA) ---
        const windowRatio = window.innerWidth / window.innerHeight;
        // Se a tela for "larga" (PC), a moto fica em baixo (0.75)
        // Se a tela for "fina" (Celular), a moto sobe para o meio (0.60) para mostrar ch√£o
        const targetVerticalPos = windowRatio > 1.5 ? 0.75 : 0.60; 

        const zoomFactor = 1.0; 
        const viewWidth = window.innerWidth * zoomFactor;
        const viewHeight = window.innerHeight * zoomFactor;
        
        const targetX = viewWidth * 0.20;
        const targetY = viewHeight * targetVerticalPos; // Posi√ß√£o Y din√¢mica

        render.bounds.min.x = chassis.position.x - targetX;
        render.bounds.max.x = chassis.position.x + (viewWidth - targetX);
        render.bounds.min.y = chassis.position.y - targetY;
        render.bounds.max.y = chassis.position.y + (viewHeight - targetY);
        
        const parallaxFactor = 0.5; 
        const bgOffsetX = -render.bounds.min.x * parallaxFactor;
        document.body.style.backgroundPositionX = bgOffsetX + "px";

        const angle = chassis.angle;
        const balanceBar = document.getElementById('balanceContainer');
        const balanceFill = document.getElementById('balanceFill');
        if (angle < -0.4) {
            balanceBar.style.display = 'block'; 
            let dangerPct = ((-angle - 0.4) / 1.0) * 100;
            balanceFill.style.width = Math.min(Math.max(dangerPct, 0), 100) + '%';
            if (dangerPct >= 99) endGame(false);
        } else {
            balanceBar.style.display = 'none';
        }

        if (keys['ArrowUp']) {
            let effectiveTorque = currentStats.torque;
            if (kmh > 100) effectiveTorque *= 0.5; 
            if (angle < -0.8) effectiveTorque *= 0.1; 
            if (kmh < currentStats.maxSpeedKmh) {
                Body.setAngularVelocity(wr, wr.angularVelocity + effectiveTorque);
                const f = currentStats.climbForce; 
                Body.applyForce(chassis, chassis.position, {x: Math.cos(chassis.angle)*f, y: Math.sin(chassis.angle)*f});
            }
        }
        if (keys['ArrowDown']) Body.setAngularVelocity(wr, wr.angularVelocity - currentStats.torque);
        const rf = currentStats.rotationSpeed, mr = currentStats.maxRotation;          
        if (keys['ArrowLeft'] && chassis.angularVelocity > -mr) Body.setAngularVelocity(chassis, chassis.angularVelocity - rf);
        if (keys['ArrowRight'] && chassis.angularVelocity < mr) Body.setAngularVelocity(chassis, chassis.angularVelocity + rf);

        const maxGauge = 220;
        const displaySpeed = Math.min(kmh, maxGauge);
        const angleGauge = -135 + (displaySpeed / maxGauge) * 270;
        document.getElementById('needle').style.transform = `translate(-50%, -100%) rotate(${angleGauge}deg)`;
        document.getElementById('speedVal').innerText = kmh;
    });

    createLevel(); 
    Render.run(render); 
    const runner = Runner.create();
    Runner.run(runner, engine);

</script>
</body>
</html>