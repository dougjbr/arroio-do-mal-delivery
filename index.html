<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Moto Delivery - Final</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #333; 
               background-image: url('fundo2.jpg'); background-repeat: repeat-x; background-size: auto 100vh; background-position: 0px 0px; 
               touch-action: none; user-select: none; }
        #resetBtn { position: absolute; top: 20px; left: 20px; background: #e74c3c; color: white; border: 2px solid #fff; padding: 10px 20px; border-radius: 20px; font-weight: bold; cursor: pointer; z-index: 20; box-shadow: 0 4px 5px rgba(0,0,0,0.3); }
        .touch-controls { position: absolute; bottom: 30px; z-index: 100; display: flex; gap: 15px; }
        .controls-left { left: 30px; } .controls-right { right: 30px; align-items: flex-end; }
        .btn { width: 80px; height: 80px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; color: white; font-size: 30px; font-weight: bold; display: flex; justify-content: center; align-items: center; backdrop-filter: blur(5px); transition: transform 0.1s, background 0.1s; cursor: pointer; -webkit-tap-highlight-color: transparent; }
        .btn:active, .btn.pressed { background: rgba(255, 255, 255, 0.5); transform: scale(0.95); }
        .btn-gas { width: 100px; height: 100px; background: rgba(46, 204, 113, 0.3); border-color: #2ecc71; }
        .btn-brake { width: 70px; height: 70px; background: rgba(231, 76, 60, 0.3); border-color: #c0392b; margin-right: 10px; }
        .btn-arrow { font-size: 40px; }
        .gas-group { display: flex; align-items: flex-end; gap: 15px; }
        .score-board { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); padding: 10px 30px; border-radius: 30px; border: 2px solid #fff; color: #fff; font-size: 24px; font-weight: bold; z-index: 10; }
        #scoreVal { color: #f1c40f; }
        #centerMessageContainer { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 90; pointer-events: none; display: none; text-shadow: 3px 3px 0 #000; font-family: 'Impact', sans-serif; text-transform: uppercase; white-space: nowrap; }
        .stage1 { color: #f1c40f; font-size: 48px; } .stage2 { color: #e67e22; font-size: 52px; } .stage3 { color: #2ecc71; font-size: 64px; } .stage4 { color: #3498db; font-size: 80px; animation: pulseBig 0.5s infinite alternate; }
        @keyframes pulseBig { from { transform: scale(1); } to { transform: scale(1.1); } }
        #balanceContainer { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); width: 200px; height: 15px; background: rgba(0,0,0,0.5); border-radius: 10px; border: 2px solid #fff; display: none; overflow: hidden; z-index: 10; }
        #balanceFill { height: 100%; width: 0%; background: linear-gradient(90deg, #f1c40f, #e74c3c); transition: width 0.1s linear; }
        #dashboard { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; z-index: 10; pointer-events: none; transform: scale(0.8); transform-origin: top right; }
        .gauge { width: 180px; height: 180px; background: #f4e6c0; border-radius: 50%; border: 8px solid #5d4037; box-shadow: inset 0 0 20px rgba(0,0,0,0.5), 0 0 0 4px #8d6e63; position: relative; display: flex; justify-content: center; align-items: center; }
        .gauge::after, .gauge::before { content: ''; position: absolute; width: 8px; height: 8px; background: #aaa; border-radius: 50%; }
        .gauge::after { top: 5px; left: 50%; transform: translateX(-50%); box-shadow: 0 154px 0 #aaa; }
        .gauge::before { left: 5px; top: 50%; transform: translateY(-50%); box-shadow: 154px 0 0 #aaa; }
        .gauge-face { width: 100%; height: 100%; position: relative; font-family: 'Courier New', monospace; font-weight: bold; color: #222; }
        .label-kmh { position: absolute; top: 65%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; color: #333; }
        .label-title { position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%); font-size: 14px; color: #5d4037; font-weight: bold; text-transform: uppercase; }
        .needle { position: absolute; top: 50%; left: 50%; width: 6px; height: 70px; background: #c0392b; border-radius: 5px; transform-origin: bottom center; transform: translate(-50%, -100%) rotate(-135deg); box-shadow: 2px 2px 5px rgba(0,0,0,0.3); transition: transform 0.1s linear; z-index: 2; }
        .needle-center { position: absolute; top: 50%; left: 50%; width: 16px; height: 16px; background: #333; transform: translate(-50%, -50%); border-radius: 50%; z-index: 3; }
        #woodSign { position: absolute; top: -50px; left: 50%; transform: translateX(-50%); background: #8b4513; color: #fff; padding: 5px 15px; border: 2px solid #5d4037; border-radius: 4px; font-family: 'Comic Sans MS', cursive; font-size: 14px; white-space: nowrap; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        #startHint { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: #fff; padding: 20px; border-radius: 10px; z-index: 300; font-size: 20px; text-align: center; border: 2px solid #fff; animation: pulse 1s infinite; cursor: pointer;}
        #audioFileControl { display: none; position: absolute; top: 60%; left: 50%; transform: translateX(-50%); z-index: 301; background: #f1c40f; padding: 10px; border-radius: 5px; color: black; font-weight: bold; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        #messageScreen { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #e74c3c; color: white; padding: 40px; border-radius: 20px; text-align: center; border: 5px solid white; z-index: 200; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        #messageScreen.win { background: #2ecc71; }
        #messageScreen h1 { margin: 0 0 10px 0; font-size: 32px; }
        #messageScreen button { background: white; color: #333; margin-top: 20px; padding: 10px 20px; border:none; font-weight:bold; cursor:pointer; font-size: 18px; border-radius: 5px;}
    </style>
</head>
<body>

<div id="startHint">TOQUE PARA LIGAR O SOM üîä</div>
<div id="audioFileControl">
    ‚ö†Ô∏è Navegador bloqueou arquivos locais.<br>
    Selecione <b>idle.mp3</b> e <b>rev.mp3</b> aqui:<br><br>
    <input type="file" id="soundFilesInput" multiple accept="audio/*" style="display:block; margin:0 auto;">
</div>

<div id="balanceContainer"><div id="balanceFill"></div></div>
<button id="resetBtn" onclick="resetGame()">‚Ü∫ REINICIAR</button>
<div class="score-board">PONTOS: <span id="scoreVal">0</span></div>
<div id="centerMessageContainer"><div id="centerMessageText"></div></div>

<div id="dashboard">
    <div class="gauge">
        <div id="woodSign">Arroio do Mal</div>
        <div class="gauge-face">
            <div class="label-title">VELOCIDADE</div>
            <div class="label-kmh"><span id="speedVal">0</span> <small>km/h</small></div>
        </div>
        <div class="needle" id="needle"></div>
        <div class="needle-center"></div>
    </div>
</div>

<div class="touch-controls controls-left">
    <div class="btn btn-arrow" id="btnLeft">‚Ü∫</div>
    <div class="btn btn-arrow" id="btnRight" style="margin-left: 10px;">‚Üª</div>
</div>
<div class="touch-controls controls-right">
    <div class="gas-group">
        <div class="btn btn-brake" id="btnDown">üõë</div>
        <div class="btn btn-gas" id="btnUp">üöÄ</div>
    </div>
</div>

<div id="messageScreen">
    <h1 id="msgTitle">CRASH! üí•</h1>
    <p id="msgText">Voc√™ virou a moto.</p>
    <button onclick="resetGame()">TENTAR NOVAMENTE</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

<script>
    const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
          Bodies = Matter.Bodies, Body = Matter.Body, Composite = Matter.Composite,
          Constraint = Matter.Constraint, Events = Matter.Events, Vector = Matter.Vector, Query = Matter.Query;

    const engine = Engine.create();
    const world = engine.world;
    engine.positionIterations = 20; 
    engine.velocityIterations = 20;
    world.gravity.y = 1.2; 

    const render = Render.create({
        element: document.body, engine: engine,
        options: { 
            width: window.innerWidth, 
            height: window.innerHeight, 
            wireframes: false, 
            background: 'transparent', 
            hasBounds: true 
        }
    });

    let chassis, riderBody, bikeComposite, currentStats, isGameOver = false;
    let groundBodies = []; 
    let score = 0; 
    let wheelieStartTime = null; 
    let terrainPoints = []; 

    const FINISH_LINE_X = 45000;
    const SCALE_FACTOR = 1.25; 
    const GROUND_THICKNESS = 120; 

    // --- √ÅUDIO ---
    let audioCtx, idleSource, revSource, idleGain, revGain, distortionNode, audioInitialized = false, idleBuffer, revBuffer;
    function initAudioContext() { if (!audioCtx) { const AudioContext = window.AudioContext || window.webkitAudioContext; audioCtx = new AudioContext(); } if (audioCtx.state === 'suspended') audioCtx.resume(); }
    function makeDistortionCurve(amount) { let k = typeof amount === 'number' ? amount : 50, n_samples = 44100, curve = new Float32Array(n_samples), deg = Math.PI / 180, i = 0, x; for ( ; i < n_samples; ++i ) { x = i * 2 / n_samples - 1; curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) ); } return curve; }
    async function autoLoadSounds() { initAudioContext(); try { const iBuff = await fetch('idle.mp3').then(res => res.arrayBuffer()); const rBuff = await fetch('rev.mp3').then(res => res.arrayBuffer()); idleBuffer = await audioCtx.decodeAudioData(iBuff); revBuffer = await audioCtx.decodeAudioData(rBuff); setupAudioNodes(); startEngineSounds(); audioInitialized = true; document.getElementById('startHint').style.display = 'none'; } catch (e) { document.getElementById('startHint').innerText = "ERRO DE ARQUIVO LOCAL"; document.getElementById('audioFileControl').style.display = 'block'; } }
    document.getElementById('soundFilesInput').addEventListener('change', async function(e) { initAudioContext(); const files = e.target.files; for (let i = 0; i < files.length; i++) { const file = files[i]; const arrayBuffer = await file.arrayBuffer(); const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer); if (file.name.toLowerCase().includes('idle')) idleBuffer = audioBuffer; if (file.name.toLowerCase().includes('rev')) revBuffer = audioBuffer; } if (idleBuffer && revBuffer) { document.getElementById('audioFileControl').style.display = 'none'; document.getElementById('startHint').style.display = 'none'; setupAudioNodes(); startEngineSounds(); audioInitialized = true; } });
    function setupAudioNodes() { idleGain = audioCtx.createGain(); revGain = audioCtx.createGain(); distortionNode = audioCtx.createWaveShaper(); distortionNode.curve = makeDistortionCurve(50); distortionNode.oversample = '4x'; idleGain.connect(audioCtx.destination); revGain.connect(distortionNode); distortionNode.connect(audioCtx.destination); }
    function startEngineSounds() { if(idleSource) try { idleSource.stop(); } catch(e){} if(revSource) try { revSource.stop(); } catch(e){} idleSource = audioCtx.createBufferSource(); idleSource.buffer = idleBuffer; idleSource.loop = true; idleSource.connect(idleGain); revSource = audioCtx.createBufferSource(); revSource.buffer = revBuffer; revSource.loop = true; revSource.connect(revGain); idleSource.start(0); revSource.start(0); }
    window.addEventListener('touchstart', autoLoadSounds, { once: true }); window.addEventListener('click', autoLoadSounds, { once: true }); window.addEventListener('keydown', autoLoadSounds, { once: true });

    // --- MOTO ---
    const BIKE_SPECS = { name: "Landera do Douglas", bodyTexture: 'lander_corpo.png', rearWheelTexture: 'lander_roda_tras.png', frontWheelTexture: 'lander_roda_frente.png', riderTexture: 'piloto.png', riderScale: 0.15, riderOffset: {x: -22, y: -29}, bodyScale: 0.169, rearWheelScale: 0.05, frontWheelScale: 0.054, axleOffset: 60, bodyHeight: 40, color: '#111', wheelSize: 24, clearance: 30, density: 0.5, torque: 0.45, climbForce: 0.3, maxSpeedKmh: 180, rotationSpeed: 0.004, maxRotation: 0.12 };
    function createBike(x, y) {
        const stats = BIKE_SPECS; currentStats = stats; const group = Body.nextGroup(true); const S = SCALE_FACTOR;
        const chassisW = 110 * S, chassisH = 30 * S, wheelSizeScaled = (stats.wheelSize || 24) * S, axleOffsetScaled = stats.axleOffset * S, bodyHeightScaled = stats.bodyHeight * S;
        let renderBody = { fillStyle: stats.color, strokeStyle: 'black', lineWidth: 2 }, renderRear = { fillStyle: 'transparent', strokeStyle: '#222', lineWidth: 8 * S }, renderFront = { fillStyle: 'transparent', strokeStyle: '#222', lineWidth: 8 * S }, renderRider = { fillStyle: '#f1c27d', strokeStyle: '#333', lineWidth: 2 };
        if (stats.bodyTexture) renderBody = { sprite: { texture: stats.bodyTexture, xScale: stats.bodyScale * S, yScale: stats.bodyScale * S } };
        if (stats.rearWheelTexture) renderRear = { sprite: { texture: stats.rearWheelTexture, xScale: stats.rearWheelScale * S, yScale: stats.rearWheelScale * S } };
        if (stats.frontWheelTexture) renderFront = { sprite: { texture: stats.frontWheelTexture, xScale: stats.frontWheelScale * S, yScale: stats.frontWheelScale * S } };
        if (stats.riderTexture) renderRider = { sprite: { texture: stats.riderTexture, xScale: stats.riderScale * S, yScale: stats.riderScale * S } };
        chassis = Bodies.rectangle(x, y - 30 * S, chassisW, chassisH, { collisionFilter: { group: group }, density: stats.density, friction: 0.5, frictionAir: 0.03, render: renderBody, label: 'chassis' });
        const currentOffsetX = stats.riderOffset.x, currentOffsetY = stats.riderOffset.y, riderSize = 25 * S, riderStartX = x + (currentOffsetX * S), riderStartY = (y - 30 * S) + (currentOffsetY * S);
        riderBody = Bodies.circle(riderStartX, riderStartY, riderSize, { collisionFilter: { group: group }, density: 0.05, friction: 0.5, render: renderRider, label: 'rider' });
        const riderJoint = Constraint.create({ bodyA: chassis, bodyB: riderBody, pointA: { x: currentOffsetX * S, y: currentOffsetY * S }, pointB: { x: 0, y: 0 }, stiffness: 1, damping: 0.1, length: 0, render: { visible: false } });
        const wheelOptsRear = { collisionFilter: { group: group }, friction: 0.8, density: 0.05, restitution: 0, render: renderRear, label: 'wheelRear' }; 
        const wheelOptsFront = { collisionFilter: { group: group }, friction: 0.8, density: 0.05, restitution: 0, render: renderFront, label: 'wheelFront' }; 
        const wheelY = y + 15 * S; 
        wheelRear = Bodies.circle(x - axleOffsetScaled, wheelY, wheelSizeScaled, wheelOptsRear);
        wheelFront = Bodies.circle(x + axleOffsetScaled, wheelY, wheelSizeScaled, wheelOptsFront);
        const suspensionOptions = { stiffness: 0.3, damping: 0.3, length: 0, render: { visible: false } };
        const axelRear = Constraint.create({ bodyA: chassis, bodyB: wheelRear, pointA: { x: -axleOffsetScaled, y: bodyHeightScaled }, pointB: { x: 0, y: 0 }, ...suspensionOptions });
        const axelFront = Constraint.create({ bodyA: chassis, bodyB: wheelFront, pointA: { x: axleOffsetScaled, y: bodyHeightScaled }, pointB: { x: 0, y: 0 }, ...suspensionOptions });
        bikeComposite = Composite.create({ bodies: [chassis, wheelRear, wheelFront, riderBody], constraints: [axelRear, axelFront, riderJoint] });
        Composite.add(world, bikeComposite); chassis.wheelRear = wheelRear; chassis.wheelFront = wheelFront;
    }

    // --- GERADOR DE TERRENO ---
    function getSplinePoints(points, segmentsPerSpan) {
        if (points.length < 4) return points; 
        const spline = [];
        for (let i = 0; i < points.length - 3; i++) {
            const p0 = points[i], p1 = points[i+1], p2 = points[i+2], p3 = points[i+3];
            for (let j = 0; j < segmentsPerSpan; j++) {
                const t = j / segmentsPerSpan, t2 = t * t, t3 = t2 * t;
                const q0 = -t3 + 2.0*t2 - t, q1 = 3.0*t3 - 5.0*t2 + 2.0, q2 = -3.0*t3 + 4.0*t2 + t, q3 = t3 - t2;
                spline.push({
                    x: 0.5 * (p0.x * q0 + p1.x * q1 + p2.x * q2 + p3.x * q3),
                    y: 0.5 * (p0.y * q0 + p1.y * q1 + p2.y * q2 + p3.y * q3)
                });
            }
        }
        spline.push(points[points.length - 2]); 
        return spline;
    }

    function createLevel() {
        groundBodies = [];
        const rawPts = [ 
            {x:-1000,y:500}, 
            {x:0,y:500},{x:1000,y:500}, {x:1400,y:600},{x:1800,y:450},{x:2200,y:600}, {x:3000,y:500},{x:4000,y:800}, {x:6000,y:1100},{x:7500,y:1100}, {x:10000,y:200}, 
            {x:11000,y:200},{x:13000,y:600}, {x:15000,y:600},{x:17000,y:400},{x:19000,y:600}, {x:21000,y:500},{x:22000,y:500}, {x:24000,y:700},{x:26000,y:300}, 
            {x:28000,y:300},{x:30000,y:800}, {x:32000,y:800},{x:33000,y:600},{x:34000,y:800}, {x:36000,y:500},{x:38000,y:200}, {x:40000,y:500},{x:42000,y:500},{x:45000,y:500},
            {x:46000,y:500}, {x:47000,y:500} 
        ];
        
        terrainPoints = getSplinePoints(rawPts, 8); 

        for(let i=0; i<terrainPoints.length-1; i++){
            let p1 = terrainPoints[i];
            let p2 = terrainPoints[i+1];
            let vec = Vector.sub(p2, p1);
            let len = Vector.magnitude(vec);
            let angle = Vector.angle(vec, {x:1,y:0});
            let mid = Vector.add(p1, Vector.mult(vec, 0.5));
            
            let segment = Bodies.rectangle(mid.x, mid.y, len + 10, GROUND_THICKNESS, { 
                isStatic: true, angle: angle, friction: 1, frictionStatic: 1, chamfer: { radius: 10 },
                render: { visible: false }, label: 'ground'
            });
            groundBodies.push(segment);
        }

        // >>> PAREDE INVIS√çVEL TRASEIRA (NOVA) <<<
        const backWall = Bodies.rectangle(-50, 0, 50, 2000, {
            isStatic: true,
            render: { visible: false }, // Invisivel para n√£o estragar o visual
            label: 'wall'
        });

        Composite.add(world, [...groundBodies, backWall, 
            Bodies.rectangle(FINISH_LINE_X, 450, 15, 300, { isStatic: true, isSensor: true, render: { fillStyle: '#fff' } }),
            Bodies.rectangle(FINISH_LINE_X + 50, 320, 100, 80, { isStatic: true, isSensor: true, render: { fillStyle: '#e74c3c' } }),
            Bodies.rectangle(FINISH_LINE_X, 600, 200, 10, { isStatic: true, render: { fillStyle: '#fff' } })
        ]);
    }

    // --- RENDERIZA√á√ÉO COM CORRE√á√ÉO DE PARALLAX E CAMADAS ---
    const groundPatternImg = new Image();
    groundPatternImg.src = 'textura_solo.jpg'; 
    let groundPattern = null;
    groundPatternImg.onload = () => { groundPattern = true; };

    Events.on(render, 'afterRender', () => {
        const ctx = render.context;
        
        // 1. Salva estado
        ctx.save();
        
        // 2. Move o "pincel" junto com a c√¢mera
        ctx.translate(-render.bounds.min.x, -render.bounds.min.y);
        
        // 3. Desenha ATR√ÅS da moto
        ctx.globalCompositeOperation = 'destination-over';

        if(terrainPoints.length > 0) {
            ctx.beginPath();
            const offsetY = GROUND_THICKNESS / 2 - 5; 
            ctx.moveTo(terrainPoints[0].x, terrainPoints[0].y - offsetY);
            for(let i=1; i<terrainPoints.length; i++){
                ctx.lineTo(terrainPoints[i].x, terrainPoints[i].y - offsetY);
            }
            let last = terrainPoints[terrainPoints.length-1];
            ctx.lineTo(last.x, last.y + 2000);
            ctx.lineTo(terrainPoints[0].x, terrainPoints[0].y + 2000);
            ctx.closePath();

             if(groundPattern === true && groundPatternImg.complete) {
                 if (!(groundPattern instanceof CanvasPattern)) { groundPattern = ctx.createPattern(groundPatternImg, 'repeat'); }
                 ctx.save();
                 ctx.fillStyle = groundPattern;
                 ctx.fill();
                 ctx.restore();
             } else {
                 ctx.fillStyle = '#4e342e'; 
                 ctx.fill();
             }

            ctx.beginPath();
            ctx.moveTo(terrainPoints[0].x, terrainPoints[0].y - offsetY);
            for(let i=1; i<terrainPoints.length; i++){
                ctx.lineTo(terrainPoints[i].x, terrainPoints[i].y - offsetY);
            }
            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = 15; ctx.strokeStyle = '#2e7d32'; ctx.stroke();
        }

        if (chassis && chassis.wheelRear && !currentStats.rearWheelTexture) {
            ctx.globalCompositeOperation = 'source-over'; 
            ctx.beginPath(); ctx.lineWidth = 4; ctx.strokeStyle = '#333';
            const wr = chassis.wheelRear;
            ctx.moveTo(wr.position.x, wr.position.y);
            ctx.lineTo(wr.position.x + Math.cos(wr.angle)*wr.circleRadius, wr.position.y + Math.sin(wr.angle)*wr.circleRadius);
            ctx.stroke();
        }
        
        // 4. Restaura para n√£o bugar o resto
        ctx.restore();
    });

    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    window.addEventListener('keydown', e => { if(e.key.toLowerCase() === 'r') resetGame(); });

    function addTouch(elemId, keyCode) {
        const el = document.getElementById(elemId);
        const handlePress = (e) => { e.preventDefault(); keys[keyCode] = true; el.classList.add('pressed'); if(!audioInitialized) autoLoadSounds(); };
        const handleRelease = (e) => { e.preventDefault(); keys[keyCode] = false; el.classList.remove('pressed'); };
        el.addEventListener('touchstart', handlePress); el.addEventListener('touchend', handleRelease);
        el.addEventListener('mousedown', handlePress); el.addEventListener('mouseup', handleRelease); el.addEventListener('mouseleave', handleRelease);
    }
    addTouch('btnUp', 'ArrowUp'); addTouch('btnDown', 'ArrowDown'); addTouch('btnLeft', 'ArrowLeft'); addTouch('btnRight', 'ArrowRight');

    function showCenterMessage(text, className) { const container = document.getElementById('centerMessageContainer'); const msgText = document.getElementById('centerMessageText'); msgText.innerText = text; msgText.className = className; container.style.display = 'block'; }
    function endGame(won) { isGameOver = true; if(audioInitialized && idleGain) { idleGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.2); revGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.2); } document.getElementById('centerMessageContainer').style.display = 'none'; const screen = document.getElementById('messageScreen'); const title = document.getElementById('msgTitle'); const txt = document.getElementById('msgText'); screen.style.display = 'block'; if(won) { screen.className = 'win'; title.innerText = "ENTREGUE! üì¶"; txt.innerText = `Pontua√ß√£o Final: ${score}`; } else { screen.className = ''; title.innerText = "CRASH! üí•"; txt.innerText = "Voc√™ virou a moto."; } }
    function resetGame() { document.getElementById('messageScreen').style.display = 'none'; document.getElementById('balanceContainer').style.display = 'none'; document.getElementById('centerMessageContainer').style.display = 'none'; isGameOver = false; score = 0; wheelieStartTime = null; document.getElementById('scoreVal').innerText = score; if(bikeComposite) Composite.remove(world, bikeComposite); createBike(100, 400); if(audioInitialized && idleGain) { idleGain.gain.setTargetAtTime(1.0, audioCtx.currentTime, 0.1); revGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1); if(audioCtx.state === 'suspended') audioCtx.resume(); } }

    Events.on(engine, 'collisionStart', (event) => { if(isGameOver) return; const pairs = event.pairs; for (let i = 0; i < pairs.length; i++) { const bodyA = pairs[i].bodyA; const bodyB = pairs[i].bodyB; if ((bodyA.label === 'chassis' && bodyB.label === 'ground') || (bodyB.label === 'chassis' && bodyA.label === 'ground') || (bodyA.label === 'rider' && bodyB.label === 'ground') || (bodyB.label === 'rider' && bodyA.label === 'ground')) { endGame(false); } } });

    Events.on(engine, 'beforeUpdate', () => {
        if (!chassis || isGameOver) return;
        if (riderBody && chassis) { Body.setAngle(riderBody, chassis.angle); Body.setAngularVelocity(riderBody, chassis.angularVelocity); }
        if (chassis.position.x >= FINISH_LINE_X) endGame(true);

        const wr = chassis.wheelRear; const wf = chassis.wheelFront;
        const speed = Vector.magnitude(chassis.velocity); const kmh = Math.round(speed * 15);

        if(audioInitialized && idleGain && revGain) {
            const isThrottleOn = keys['ArrowUp'];
            const targetIdleVol = isThrottleOn ? 0.3 : 1.0;
            const targetRevVol = isThrottleOn ? 1.0 : 0.0;
            idleGain.gain.setTargetAtTime(targetIdleVol, audioCtx.currentTime, 0.1);
            revGain.gain.setTargetAtTime(targetRevVol, audioCtx.currentTime, 0.1);
            idleSource.playbackRate.value = 0.9 + (kmh * 0.002); 
            let revPitch = 0.8 + (kmh * 0.003) + (isThrottleOn ? 0.1 : 0);
            revSource.playbackRate.value = revPitch;
        }

        const rearCollisions = Query.collides(wr, groundBodies);
        const frontCollisions = Query.collides(wf, groundBodies);
        const rearOnGround = rearCollisions.length > 0;
        const frontOnGround = frontCollisions.length > 0;
        const isDoingWheelie = rearOnGround && !frontOnGround && kmh > 10;

        if (isDoingWheelie) { if (wheelieStartTime === null) { wheelieStartTime = Date.now(); } const currentDuration = (Date.now() - wheelieStartTime) / 1000; let pointsMultiplier = 1; if (currentDuration > 8) { showCenterMessage("Mestre do Grau!! üëë", "stage4"); pointsMultiplier = 20; } else if (currentDuration > 5) { showCenterMessage("Bom Grau! üëç", "stage3"); pointsMultiplier = 10; } else if (currentDuration > 4) { showCenterMessage("Grau Murcho üòê", "stage2"); pointsMultiplier = 5; } else if (currentDuration > 1) { showCenterMessage("Chama no Grau!! üî•", "stage1"); pointsMultiplier = 2; } if (currentDuration > 1) { score += pointsMultiplier; document.getElementById('scoreVal').innerText = score; } } else { wheelieStartTime = null; document.getElementById('centerMessageContainer').style.display = 'none'; }

        const MAX_WHEEL_SPIN = 0.6;
        if (wr.angularVelocity > MAX_WHEEL_SPIN) Body.setAngularVelocity(wr, MAX_WHEEL_SPIN);
        if (wr.angularVelocity < -MAX_WHEEL_SPIN) Body.setAngularVelocity(wr, -MAX_WHEEL_SPIN);

        // C√¢mera Fixa na Moto
        const zoomFactor = 1.0; 
        const viewWidth = window.innerWidth * zoomFactor;
        const viewHeight = window.innerHeight * zoomFactor;
        const targetX = viewWidth * 0.30; 
        const targetY = viewHeight * 0.65; 

        render.bounds.min.x = chassis.position.x - targetX;
        render.bounds.max.x = chassis.position.x + (viewWidth - targetX);
        render.bounds.min.y = chassis.position.y - targetY;
        render.bounds.max.y = chassis.position.y + (viewHeight - targetY);
        
        const parallaxFactor = 0.5; 
        const bgOffsetX = -render.bounds.min.x * parallaxFactor;
        document.body.style.backgroundPositionX = bgOffsetX + "px";

        const angle = chassis.angle;
        const balanceBar = document.getElementById('balanceContainer');
        const balanceFill = document.getElementById('balanceFill');
        if (angle < -0.4) { balanceBar.style.display = 'block'; let dangerPct = ((-angle - 0.4) / 1.0) * 100; balanceFill.style.width = Math.min(Math.max(dangerPct, 0), 100) + '%'; if (dangerPct >= 99) endGame(false); } else { balanceBar.style.display = 'none'; }

        if (keys['ArrowUp']) {
            let effectiveTorque = currentStats.torque;
            if (kmh > 100) effectiveTorque *= 0.5; 
            if (angle < -0.8) effectiveTorque *= 0.1; 
            if (kmh < currentStats.maxSpeedKmh) {
                Body.setAngularVelocity(wr, wr.angularVelocity + effectiveTorque);
                const f = currentStats.climbForce; 
                Body.applyForce(chassis, chassis.position, {x: Math.cos(chassis.angle)*f, y: Math.sin(chassis.angle)*f});
            }
        }
        if (keys['ArrowDown']) Body.setAngularVelocity(wr, wr.angularVelocity - currentStats.torque);
        const rf = currentStats.rotationSpeed, mr = currentStats.maxRotation;           
        if (keys['ArrowLeft'] && chassis.angularVelocity > -mr) Body.setAngularVelocity(chassis, chassis.angularVelocity - rf);
        if (keys['ArrowRight'] && chassis.angularVelocity < mr) Body.setAngularVelocity(chassis, chassis.angularVelocity + rf);

        const maxGauge = 220;
        const displaySpeed = Math.min(kmh, maxGauge);
        const angleGauge = -135 + (displaySpeed / maxGauge) * 270;
        document.getElementById('needle').style.transform = `translate(-50%, -100%) rotate(${angleGauge}deg)`;
        document.getElementById('speedVal').innerText = kmh;
    });

    createLevel(); resetGame();
    Render.run(render); Runner.run(Runner.create(), engine);

</script>
</body>
</html>